<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì´ë¯¸ì§€ ìˆ˜ì • & WEBP ë³€í™˜ ë„êµ¬</title>
    <!-- ffmpeg.wasm CDN (ë¹„ë””ì˜¤â†’WEBP ë³€í™˜ìš©, ë°°ê²½ì œê±°ì™€ ë¬´ê´€) -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.js" onerror="console.warn('FFmpeg ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì‹¤íŒ¨ (ë¹„ë””ì˜¤ ë³€í™˜ ê¸°ëŠ¥ë§Œ ì˜í–¥)')"></script>
    <script src="https://unpkg.com/@ffmpeg/util@0.12.1/dist/umd/util.js" onerror="console.warn('FFmpeg util ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì‹¤íŒ¨ (ë¹„ë””ì˜¤ ë³€í™˜ ê¸°ëŠ¥ë§Œ ì˜í–¥)')"></script>
    <script>
        // FFmpeg ë¡œë“œ í™•ì¸ (ì¡°ìš©íˆ ì²˜ë¦¬, ë°°ê²½ì œê±° ê¸°ëŠ¥ê³¼ ë¬´ê´€)
        window.addEventListener('load', function() {
            if (typeof FFmpeg === 'undefined') {
                console.warn('FFmpegê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¹„ë””ì˜¤ ë³€í™˜ ê¸°ëŠ¥ë§Œ ì˜í–¥ë°›ìŠµë‹ˆë‹¤.');
            }
        });
    </script>
    <link rel="icon" href="data:,">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative;
        }
        
        .backend-status {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #888;
            box-shadow: 0 0 8px rgba(0,0,0,0.3);
            transition: all 0.5s ease;
            opacity: 0.5;
            transform: scale(0.8);
        }
        
        .status-indicator.online {
            background: #4ade80;
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.6);
            animation: pulse 2s infinite, fadeInScale 0.5s ease;
            opacity: 1;
            transform: scale(1);
        }
        
        .status-indicator.offline {
            background: #f87171;
            box-shadow: 0 0 8px rgba(248, 113, 113, 0.4);
            opacity: 0.8;
            transform: scale(0.9);
        }
        
        .status-indicator.checking {
            background: #fbbf24;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
            opacity: 0.7;
            transform: scale(0.85);
            animation: checkingPulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { 
                opacity: 1;
                box-shadow: 0 0 12px rgba(74, 222, 128, 0.6);
            }
            50% { 
                opacity: 0.8;
                box-shadow: 0 0 16px rgba(74, 222, 128, 0.8);
            }
        }
        
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.5);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes checkingPulse {
            0%, 100% { 
                opacity: 0.7;
            }
            50% { 
                opacity: 1;
            }
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            opacity: 0.9;
            font-size: 1.2em;
        }

        /* íƒ­ ìŠ¤íƒ€ì¼ */
        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 3px solid #e0e0e0;
        }

        .tab-button {
            flex: 1;
            padding: 20px 30px;
            background: transparent;
            border: none;
            font-size: 1.3em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            color: #666;
            border-bottom: 3px solid transparent;
        }

        .tab-button:hover {
            background: #e8ebff;
            color: #667eea;
        }

        .tab-button.active {
            background: white;
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
            padding: 40px;
            animation: fadeIn 0.3s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ê³µí†µ ìŠ¤íƒ€ì¼ */
        .upload-section {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 50px;
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #f8f9ff 0%, #f0f2ff 100%);
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-section:hover {
            border-color: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.2);
        }

        .upload-section.dragover {
            border-color: #764ba2;
            background: linear-gradient(135deg, #e8ebff 0%, #e0e3ff 100%);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 5em;
            margin-bottom: 20px;
            filter: drop-shadow(0 5px 10px rgba(0,0,0,0.1));
        }

        .upload-text {
            font-size: 1.3em;
            color: #667eea;
            margin-bottom: 25px;
            font-weight: 600;
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 18px 35px;
            font-size: 1.2em;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .settings-panel {
            background: linear-gradient(135deg, #f8f9ff 0%, #f0f2ff 100%);
            border-radius: 15px;
            padding: 35px;
            margin-bottom: 30px;
            border: 2px solid #e8ebff;
        }

        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .settings-row:last-child {
            margin-bottom: 0;
        }

        .settings-row label {
            font-weight: 700;
            color: #333;
            min-width: 140px;
            font-size: 1.1em;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        input[type="number"], input[type="text"], input[type="time"] {
            padding: 12px 18px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1.1em;
            width: 120px;
            transition: all 0.3s;
            font-weight: 600;
        }

        input[type="number"]:focus, input[type="text"]:focus, input[type="time"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 20px;
            background: white;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
        }

        input[type="checkbox"] {
            width: 24px;
            height: 24px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .format-selector {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .format-option {
            position: relative;
        }

        .format-option input[type="radio"] {
            position: absolute;
            opacity: 0;
        }

        .format-option label {
            display: block;
            padding: 12px 25px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }

        .format-option input[type="radio"]:checked + label {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            transform: scale(1.05);
        }

        .format-option label:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .preview-section {
            margin-top: 30px;
        }

        .preview-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
            margin-top: 25px;
        }

        .preview-item {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            transition: all 0.3s;
            border: 2px solid #f0f0f0;
        }

        .preview-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 30px rgba(0,0,0,0.15);
        }

        .preview-item img, .preview-item video {
            width: 100%;
            height: auto;
            border-radius: 10px;
            margin-bottom: 15px;
            max-height: 300px;
            object-fit: contain;
        }

        .preview-item .filename {
            font-weight: 700;
            color: #333;
            margin-bottom: 8px;
            font-size: 1.05em;
            word-break: break-all;
        }

        .preview-item .status {
            color: #666;
            font-size: 0.95em;
            padding: 5px 10px;
            background: #f8f9fa;
            border-radius: 5px;
            display: inline-block;
        }

        .preview-item .status.processing {
            color: #667eea;
            background: #e8ebff;
        }

        .preview-item .status.complete {
            color: #28a745;
            background: #d4edda;
        }

        .preview-item .status.error {
            color: #dc3545;
            background: #f8d7da;
        }

        .progress-bar-container {
            background: #e0e0e0;
            border-radius: 15px;
            height: 40px;
            margin: 25px 0;
            overflow: hidden;
            display: none;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }

        .progress-bar {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 1.1em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }

        .action-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 40px;
            flex-wrap: wrap;
        }

        .hidden {
            display: none;
        }

        .message {
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            font-weight: 600;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .error-message {
            background: linear-gradient(135deg, #fee 0%, #fdd 100%);
            color: #c33;
            border-left: 5px solid #c33;
        }

        .success-message {
            background: linear-gradient(135deg, #efe 0%, #dfd 100%);
            color: #3c3;
            border-left: 5px solid #3c3;
        }

        .info-message {
            background: linear-gradient(135deg, #eef 0%, #ddf 100%);
            color: #336;
            border-left: 5px solid #336;
        }

        .file-count {
            margin-top: 15px;
            color: #667eea;
            font-weight: 600;
            font-size: 1.1em;
        }

        /* ì›Œí„°ë§ˆí¬ ìœ„ì¹˜ ê·¸ë¦¬ë“œ */
        .position-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 300px;
        }

        .position-btn {
            padding: 15px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1.5em;
            font-weight: 700;
            text-align: center;
        }

        .position-btn:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .position-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        /* ì›Œí„°ë§ˆí¬ ë¯¸ë¦¬ë³´ê¸° */
        .watermark-preview {
            width: 100%;
            height: 100px;
            background: #222;
            border-radius: 10px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5em;
            position: relative;
            overflow: hidden;
        }

        /* ìŠ¬ë¼ì´ë” */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .slider {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            min-width: 60px;
            text-align: center;
            font-weight: 700;
            color: #667eea;
        }

        /* 2ì—´ ë ˆì´ì•„ì›ƒ */
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        @media (max-width: 768px) {
            .two-column {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="backend-status">
                <div class="status-indicator checking" id="backendStatusIndicator"></div>
                <span id="backendStatusText">ë°±ì—”ë“œ í™•ì¸ ì¤‘...</span>
            </div>
            <h1>ğŸ–¼ï¸ ì´ë¯¸ì§€ ìˆ˜ì • & WEBP ë³€í™˜ ë„êµ¬</h1>
            <p>ì´ë¯¸ì§€ ìˆ˜ì • ë° MP4 â†’ WEBP ë³€í™˜ì„ í•œ ê³³ì—ì„œ</p>
        </div>

        <!-- íƒ­ ë©”ë‰´ -->
        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('image')">
                ğŸ–¼ï¸ ì´ë¯¸ì§€ ìˆ˜ì •
            </button>
            <button class="tab-button" onclick="switchTab('webp')">
                ğŸ¬ WEBP ë³€í™˜
            </button>
        </div>

        <!-- ì´ë¯¸ì§€ ìˆ˜ì • íƒ­ -->
        <div id="imageTab" class="tab-content active">
            <!-- íŒŒì¼ ì—…ë¡œë“œ ì„¹ì…˜ -->
            <div class="upload-section" id="imageUploadSection" onclick="document.getElementById('imageFileInput').click()">
                <div class="upload-icon">ğŸ“</div>
                <div class="upload-text">
                    ì´ë¯¸ì§€ë¥¼ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”
                </div>
                <input type="file" id="imageFileInput" class="file-input" multiple accept="image/*">
                <div class="file-count" id="imageFileCount" style="display: none;"></div>
            </div>

            <!-- ì„¤ì • íŒ¨ë„ -->
            <div class="settings-panel">
                <div class="settings-row">
                    <label>ğŸ“ ì¶œë ¥ í•´ìƒë„:</label>
                    <div class="input-group">
                        <input type="number" id="imageWidthInput" value="600" min="1" max="4000">
                        <span style="font-weight: 700; font-size: 1.2em;">Ã—</span>
                        <input type="number" id="imageHeightInput" value="600" min="1" max="4000">
                        <span style="color: #667eea; font-weight: 600;">px</span>
                    </div>
                </div>

                <div class="settings-row">
                    <label>ğŸ¨ ë°°ê²½ ì œê±°:</label>
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="bgRemovalCheck" checked>
                        <span style="font-weight: 600;">ë°°ê²½ ì œê±° í™œì„±í™”</span>
                    </div>
                </div>

                <div class="settings-row">
                    <label>ğŸ’¾ ì €ì¥ í˜•ì‹:</label>
                    <div class="format-selector">
                        <div class="format-option">
                            <input type="radio" name="imageFormat" id="formatJPG" value="jpg" checked>
                            <label for="formatJPG">JPG</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" name="imageFormat" id="formatPNG" value="png">
                            <label for="formatPNG">PNG</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" name="imageFormat" id="formatWEBP" value="webp">
                            <label for="formatWEBP">WEBP</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" name="imageFormat" id="formatGIF" value="gif">
                            <label for="formatGIF">GIF</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ì§„í–‰ë¥  ë°” -->
            <div class="progress-bar-container" id="imageProgressContainer">
                <div class="progress-bar" id="imageProgressBar">0%</div>
            </div>

            <!-- ë©”ì‹œì§€ ì˜ì—­ -->
            <div id="imageMessageArea"></div>

            <!-- ë¯¸ë¦¬ë³´ê¸° ì„¹ì…˜ -->
            <div class="preview-section" id="imagePreviewSection" style="display: none;">
                <h2 style="margin-bottom: 25px; color: #333; font-size: 1.8em;">ì„ íƒëœ ì´ë¯¸ì§€</h2>
                <div class="preview-container" id="imagePreviewContainer"></div>
            </div>

            <!-- ì•¡ì…˜ ë²„íŠ¼ -->
            <div class="action-buttons">
                <button class="btn" id="imageProcessBtn" onclick="processImages()" disabled>
                    âœ¨ ì´ë¯¸ì§€ ìˆ˜ì • ì‹œì‘
                </button>
                <button class="btn btn-danger" id="imageClearBtn" onclick="clearImageAll()" style="display: none;">
                    ğŸ—‘ï¸ ëª¨ë‘ ì§€ìš°ê¸°
                </button>
            </div>
        </div>

        <!-- WEBP ë³€í™˜ íƒ­ -->
        <div id="webpTab" class="tab-content">
            <div class="two-column">
                <!-- ì™¼ìª½: ì›Œí„°ë§ˆí¬ ì„¤ì • -->
                <div>
                    <div class="settings-panel">
                        <h3 style="margin-bottom: 20px; color: #667eea;">ì›Œí„°ë§ˆí¬ ì„¤ì •</h3>
                        
                        <div class="settings-row">
                            <label>í…ìŠ¤íŠ¸:</label>
                            <input type="text" id="watermarkText" value="luxmixlounge.com" style="flex: 1;">
                        </div>

                        <div class="settings-row">
                            <label>ìƒ‰ìƒ:</label>
                            <input type="color" id="watermarkColor" value="#FFFFFF" style="width: 80px; height: 40px; border: 2px solid #e0e0e0; border-radius: 10px; cursor: pointer;">
                        </div>

                        <div class="settings-row">
                            <label>í¬ê¸°:</label>
                            <div class="slider-container">
                                <input type="range" id="fontSizeSlider" class="slider" min="10" max="100" value="24">
                                <span class="slider-value" id="fontSizeValue">24</span>
                            </div>
                        </div>

                        <div class="settings-row">
                            <label>íˆ¬ëª…ë„:</label>
                            <div class="slider-container">
                                <input type="range" id="opacitySlider" class="slider" min="0" max="100" value="50" step="10">
                                <span class="slider-value" id="opacityValue">50%</span>
                            </div>
                        </div>

                        <div class="settings-row">
                            <label>ìœ„ì¹˜:</label>
                            <div class="position-grid">
                                <div class="position-btn" data-pos="top-left" onclick="selectPosition('top-left')">â†–</div>
                                <div class="position-btn" data-pos="top-center" onclick="selectPosition('top-center')">â†‘</div>
                                <div class="position-btn" data-pos="top-right" onclick="selectPosition('top-right')">â†—</div>
                                <div class="position-btn" data-pos="mid-left" onclick="selectPosition('mid-left')">â†</div>
                                <div class="position-btn active" data-pos="mid-center" onclick="selectPosition('mid-center')">â—</div>
                                <div class="position-btn" data-pos="mid-right" onclick="selectPosition('mid-right')">â†’</div>
                                <div class="position-btn" data-pos="bot-left" onclick="selectPosition('bot-left')">â†™</div>
                                <div class="position-btn" data-pos="bot-center" onclick="selectPosition('bot-center')">â†“</div>
                                <div class="position-btn" data-pos="bot-right" onclick="selectPosition('bot-right')">â†˜</div>
                            </div>
                        </div>

                        <div class="watermark-preview" id="watermarkPreview">
                            <span id="watermarkPreviewText">luxmixlounge.com</span>
                        </div>
                    </div>
                </div>

                <!-- ì˜¤ë¥¸ìª½: ì˜ìƒ ì„¤ì • -->
                <div>
                    <div class="settings-panel">
                        <h3 style="margin-bottom: 20px; color: #667eea;">ì˜ìƒ ì„¤ì •</h3>
                        
                        <div class="settings-row">
                            <label>ì˜ìƒ ê¸¸ì´:</label>
                            <div class="format-selector">
                                <div class="format-option">
                                    <input type="radio" name="videoLength" id="fullVideo" value="full" checked>
                                    <label for="fullVideo">ì „ì²´ ì˜ìƒ</label>
                                </div>
                                <div class="format-option">
                                    <input type="radio" name="videoLength" id="partialVideo" value="partial">
                                    <label for="partialVideo">ì˜ìƒ ì¼ë¶€</label>
                                </div>
                            </div>
                        </div>

                        <div class="settings-row" id="timeRangeRow" style="display: none;">
                            <label>êµ¬ê°„ ì„¤ì •:</label>
                            <div class="input-group">
                                <input type="text" id="startTime" value="00:00:00" placeholder="00:00:00" pattern="[0-9]{2}:[0-9]{2}:[0-9]{2}">
                                <span style="font-weight: 700;">~</span>
                                <input type="text" id="endTime" value="00:00:05" placeholder="00:00:05" pattern="[0-9]{2}:[0-9]{2}:[0-9]{2}">
                            </div>
                        </div>

                        <div class="settings-row">
                            <label>ê°€ë¡œ í¬ê¸°:</label>
                            <div class="input-group">
                                <input type="number" id="videoWidth" value="600" min="100" max="4000">
                                <span style="color: #667eea; font-weight: 600;">px</span>
                            </div>
                        </div>

                        <div class="settings-row">
                            <label>ì¶œë ¥ í˜•ì‹:</label>
                            <div class="format-selector">
                                <div class="format-option">
                                    <input type="radio" name="webpFormat" id="formatWEBP" value="webp" checked>
                                    <label for="formatWEBP">WEBP</label>
                                </div>
                                <div class="format-option">
                                    <input type="radio" name="webpFormat" id="formatGIF" value="gif">
                                    <label for="formatGIF">GIF</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- íŒŒì¼ ì—…ë¡œë“œ ì„¹ì…˜ -->
            <div class="upload-section" id="webpUploadSection" onclick="document.getElementById('webpFileInput').click()">
                <div class="upload-icon">ğŸ¬</div>
                <div class="upload-text">
                    MP4 íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”
                </div>
                <input type="file" id="webpFileInput" class="file-input" multiple accept="video/mp4">
                <div class="file-count" id="webpFileCount" style="display: none;"></div>
            </div>

            <!-- ì§„í–‰ë¥  ë°” -->
            <div class="progress-bar-container" id="webpProgressContainer">
                <div class="progress-bar" id="webpProgressBar">0%</div>
            </div>

            <!-- ë©”ì‹œì§€ ì˜ì—­ -->
            <div id="webpMessageArea"></div>

            <!-- ë¯¸ë¦¬ë³´ê¸° ì„¹ì…˜ -->
            <div class="preview-section" id="webpPreviewSection" style="display: none;">
                <h2 style="margin-bottom: 25px; color: #333; font-size: 1.8em;">ì„ íƒëœ ì˜ìƒ</h2>
                <div class="preview-container" id="webpPreviewContainer"></div>
            </div>

            <!-- ì•¡ì…˜ ë²„íŠ¼ -->
            <div class="action-buttons">
                <button class="btn" id="webpProcessBtn" onclick="processWebp()" disabled>
                    âœ¨ WEBP ë³€í™˜ ì‹œì‘
                </button>
                <button class="btn btn-danger" id="webpClearBtn" onclick="clearWebpAll()" style="display: none;">
                    ğŸ—‘ï¸ ëª¨ë‘ ì§€ìš°ê¸°
                </button>
            </div>
        </div>
    </div>

    <script>
        // ========== íƒ­ ì „í™˜ ==========
        function switchTab(tab) {
            // íƒ­ ë²„íŠ¼ í™œì„±í™”
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            if (tab === 'image') {
                document.querySelector('.tab-button:first-child').classList.add('active');
                document.getElementById('imageTab').classList.add('active');
            } else if (tab === 'webp') {
                document.querySelector('.tab-button:last-child').classList.add('active');
                document.getElementById('webpTab').classList.add('active');
            }
        }

        // ========== ì´ë¯¸ì§€ ì²˜ë¦¬ ==========
        let imageFiles = [];
        let processedImages = [];

        // ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ
        document.getElementById('imageFileInput').addEventListener('change', (e) => {
            handleImageFiles(e.target.files);
        });

        // ì´ë¯¸ì§€ ë“œë˜ê·¸ ì•¤ ë“œë¡­
        const imageUploadSection = document.getElementById('imageUploadSection');
        imageUploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            imageUploadSection.classList.add('dragover');
        });
        imageUploadSection.addEventListener('dragleave', () => {
            imageUploadSection.classList.remove('dragover');
        });
        imageUploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            imageUploadSection.classList.remove('dragover');
            handleImageFiles(e.dataTransfer.files);
        });

        function handleImageFiles(files) {
            imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
            updateImageFileCount();
            updateImagePreview();
            document.getElementById('imageProcessBtn').disabled = imageFiles.length === 0;
            document.getElementById('imageClearBtn').style.display = imageFiles.length > 0 ? 'inline-block' : 'none';
        }

        function updateImageFileCount() {
            const countEl = document.getElementById('imageFileCount');
            if (imageFiles.length > 0) {
                countEl.textContent = `ì„ íƒëœ íŒŒì¼: ${imageFiles.length}ê°œ`;
                countEl.style.display = 'block';
            } else {
                countEl.style.display = 'none';
            }
        }

        function updateImagePreview() {
            const container = document.getElementById('imagePreviewContainer');
            container.innerHTML = '';
            
            imageFiles.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const div = document.createElement('div');
                    div.className = 'preview-item';
                    div.id = `imagePreview-${index}`;
                    div.innerHTML = `
                        <img src="${e.target.result}" alt="${file.name}">
                        <div class="filename">${file.name}</div>
                        <div class="status">ëŒ€ê¸° ì¤‘</div>
                    `;
                    container.appendChild(div);
                };
                reader.readAsDataURL(file);
            });
            
            document.getElementById('imagePreviewSection').style.display = imageFiles.length > 0 ? 'block' : 'none';
        }

        async function processImages() {
            if (imageFiles.length === 0) {
                showImageMessage('ì´ë¯¸ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.', 'error');
                return;
            }

            const width = parseInt(document.getElementById('imageWidthInput').value);
            const height = parseInt(document.getElementById('imageHeightInput').value);
            const removeBg = document.getElementById('bgRemovalCheck').checked;
            const format = document.querySelector('input[name="imageFormat"]:checked').value;

            if (width < 1 || height < 1) {
                showImageMessage('í•´ìƒë„ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
                return;
            }

            document.getElementById('imageProcessBtn').disabled = true;
            processedImages = [];
            updateImageProgress(0);

            try {
                for (let i = 0; i < imageFiles.length; i++) {
                    const file = imageFiles[i];
                    const progress = ((i + 1) / imageFiles.length) * 100;
                    updateImageProgress(progress);
                    updateImagePreviewStatus(i, 'ì²˜ë¦¬ ì¤‘...', 'processing');
                    
                    try {
                        const processed = await processImage(file, width, height, removeBg, format);
                        processedImages.push(processed);
                        updateImagePreviewStatus(i, 'ì™„ë£Œ âœ“', 'complete');
                    } catch (error) {
                        updateImagePreviewStatus(i, 'ì˜¤ë¥˜ âœ—', 'error');
                        showImageMessage(`${file.name} ì²˜ë¦¬ ì‹¤íŒ¨: ${error.message}`, 'error');
                    }
                }

                updateImageProgress(100);
                showImageMessage(`ëª¨ë“  ì´ë¯¸ì§€ ì²˜ë¦¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! (${processedImages.length}ê°œ)`, 'success');
                
                // ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ í‘œì‹œ
                const actionButtons = document.querySelector('#imageTab .action-buttons');
                const existingDownloadBtn = document.getElementById('imageDownloadAllBtn');
                if (processedImages.length > 0 && !existingDownloadBtn) {
                    const downloadBtn = document.createElement('button');
                    downloadBtn.id = 'imageDownloadAllBtn';
                    downloadBtn.className = 'btn btn-success';
                    downloadBtn.textContent = 'ğŸ“¥ ëª¨ë‘ ë‹¤ìš´ë¡œë“œ';
                    downloadBtn.onclick = downloadAllImages;
                    actionButtons.appendChild(downloadBtn);
                }
                
            } catch (error) {
                showImageMessage('ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message, 'error');
            } finally {
                document.getElementById('imageProcessBtn').disabled = false;
            }
        }

        // ê°œì„ ëœ ë°°ê²½ ì œê±° í•¨ìˆ˜ (ë‹¤ì¤‘ ìƒ˜í”Œë§ + ì—£ì§€ ê°ì§€)
        function removeBackground(canvas, ctx, img, x, y, imgWidth, imgHeight) {
            // ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ì„ì‹œ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            // ê³ í’ˆì§ˆ ë³´ê°„ ì„¤ì •
            tempCtx.imageSmoothingEnabled = true;
            tempCtx.imageSmoothingQuality = 'high';
            tempCtx.drawImage(img, 0, 0);
            
            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            const data = imageData.data;
            const width = img.width;
            const height = img.height;
            
            // 1. ê°€ì¥ìë¦¬ ìƒ‰ìƒ ìƒ˜í”Œë§ (ë” ë§ì€ ìƒ˜í”Œ)
            const edgeSamples = [];
            const sampleSize = Math.max(20, Math.floor(Math.min(width, height) / 10));
            
            // ëª¨ì„œë¦¬ ì˜ì—­ ìƒ˜í”Œë§ (ë” ì •í™•í•œ ë°°ê²½ìƒ‰ ì¶”ì •)
            const cornerSize = Math.min(50, Math.floor(Math.min(width, height) / 4));
            
            // 4ê°œ ëª¨ì„œë¦¬ ì˜ì—­ ìƒ˜í”Œë§
            for (let py = 0; py < cornerSize; py++) {
                for (let px = 0; px < cornerSize; px++) {
                    // ì¢Œìƒë‹¨
                    let idx = (px + py * width) * 4;
                    edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
                    
                    // ìš°ìƒë‹¨
                    idx = ((width - 1 - px) + py * width) * 4;
                    edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
                    
                    // ì¢Œí•˜ë‹¨
                    idx = (px + (height - 1 - py) * width) * 4;
                    edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
                    
                    // ìš°í•˜ë‹¨
                    idx = ((width - 1 - px) + (height - 1 - py) * width) * 4;
                    edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
                }
            }
            
            // ê°€ì¥ìë¦¬ ë¼ì¸ ìƒ˜í”Œë§
            for (let i = 0; i < sampleSize; i++) {
                const px = Math.floor((i / sampleSize) * width);
                // ìƒë‹¨
                let idx = (px + 0) * 4;
                edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
                // í•˜ë‹¨
                idx = (px + (height - 1) * width) * 4;
                edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
            }
            
            for (let i = 0; i < sampleSize; i++) {
                const py = Math.floor((i / sampleSize) * height);
                // ì¢Œì¸¡
                let idx = (0 + py * width) * 4;
                edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
                // ìš°ì¸¡
                idx = ((width - 1) + py * width) * 4;
                edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
            }
            
            // 2. ë°°ê²½ìƒ‰ í´ëŸ¬ìŠ¤í„°ë§ (K-means ìŠ¤íƒ€ì¼)
            const bgColors = [];
            const clusters = {};
            
            edgeSamples.forEach(sample => {
                const key = `${Math.floor(sample[0]/10)}_${Math.floor(sample[1]/10)}_${Math.floor(sample[2]/10)}`;
                if (!clusters[key]) {
                    clusters[key] = { r: 0, g: 0, b: 0, count: 0 };
                }
                clusters[key].r += sample[0];
                clusters[key].g += sample[1];
                clusters[key].b += sample[2];
                clusters[key].count++;
            });
            
            // ê°€ì¥ ë§ì´ ë‚˜íƒ€ë‚˜ëŠ” ìƒ‰ìƒ í´ëŸ¬ìŠ¤í„° ì°¾ê¸°
            let maxCount = 0;
            let dominantColor = null;
            Object.values(clusters).forEach(cluster => {
                if (cluster.count > maxCount) {
                    maxCount = cluster.count;
                    dominantColor = {
                        r: Math.floor(cluster.r / cluster.count),
                        g: Math.floor(cluster.g / cluster.count),
                        b: Math.floor(cluster.b / cluster.count)
                    };
                }
            });
            
            if (!dominantColor) {
                // í´ë°±: í‰ê·  ìƒ‰ìƒ
                let avgR = 0, avgG = 0, avgB = 0;
                edgeSamples.forEach(sample => {
                    avgR += sample[0];
                    avgG += sample[1];
                    avgB += sample[2];
                });
                dominantColor = {
                    r: Math.floor(avgR / edgeSamples.length),
                    g: Math.floor(avgG / edgeSamples.length),
                    b: Math.floor(avgB / edgeSamples.length)
                };
            }
            
            // 3. ì—£ì§€ ê°ì§€ (Sobel í•„í„° ìŠ¤íƒ€ì¼)
            const edgeMap = new Uint8Array(width * height);
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (x + y * width) * 4;
                    const idxL = ((x - 1) + y * width) * 4;
                    const idxR = ((x + 1) + y * width) * 4;
                    const idxU = (x + (y - 1) * width) * 4;
                    const idxD = (x + (y + 1) * width) * 4;
                    
                    const gx = Math.abs(data[idxR] - data[idxL]);
                    const gy = Math.abs(data[idxD] - data[idxU]);
                    const edge = Math.sqrt(gx * gx + gy * gy);
                    edgeMap[x + y * width] = edge > 30 ? 255 : 0;
                }
            }
            
            // 4. ë°°ê²½ ì œê±° (ì ì‘í˜• ì„ê³„ê°’)
            const baseThreshold = 50;
            const edgeThreshold = 30; // ì—£ì§€ ê·¼ì²˜ëŠ” ë” ì—„ê²©í•˜ê²Œ
            
            for (let i = 0; i < data.length; i += 4) {
                const px = (i / 4) % width;
                const py = Math.floor((i / 4) / width);
                const isEdge = edgeMap[px + py * width] > 0;
                
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // ìƒ‰ìƒ ê±°ë¦¬ ê³„ì‚° (CIE76 ìƒ‰ìƒ ê³µê°„)
                const dr = r - dominantColor.r;
                const dg = g - dominantColor.g;
                const db = b - dominantColor.b;
                const distance = Math.sqrt(dr * dr + dg * dg + db * db);
                
                // ì ì‘í˜• ì„ê³„ê°’
                let threshold = baseThreshold;
                if (isEdge) {
                    threshold = edgeThreshold; // ì—£ì§€ ê·¼ì²˜ëŠ” ë” ì—„ê²©
                } else if (px < cornerSize || px > width - cornerSize || 
                          py < cornerSize || py > height - cornerSize) {
                    threshold = baseThreshold * 1.5; // ê°€ì¥ìë¦¬ëŠ” ë” ê´€ëŒ€í•˜ê²Œ
                }
                
                // ë°°ê²½ ì œê±°
                if (distance < threshold) {
                    // ê·¸ë¼ë°ì´ì…˜ ì²˜ë¦¬ (ë¶€ë“œëŸ¬ìš´ ì „í™˜)
                    const alpha = Math.min(255, Math.floor((distance / threshold) * 255));
                    data[i + 3] = alpha;
                } else {
                    data[i + 3] = 255; // ì „ê²½ì€ ë¶ˆíˆ¬ëª…
                }
            }
            
            // 5. ëª¨í´ë¡œì§€ ì—°ì‚° (ë…¸ì´ì¦ˆ ì œê±°)
            const processedData = new Uint8ClampedArray(data);
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (x + y * width) * 4;
                    const alpha = data[idx + 3];
                    
                    // ì£¼ë³€ í”½ì…€ì˜ ì•ŒíŒŒê°’ í™•ì¸
                    let neighborCount = 0;
                    let transparentCount = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nIdx = ((x + dx) + (y + dy) * width) * 4;
                            neighborCount++;
                            if (data[nIdx + 3] < 128) transparentCount++;
                        }
                    }
                    
                    // ê³ ë¦½ëœ í”½ì…€ ì œê±°
                    if (alpha > 128 && transparentCount > neighborCount * 0.7) {
                        processedData[idx + 3] = 0;
                    } else if (alpha < 128 && transparentCount < neighborCount * 0.3) {
                        processedData[idx + 3] = 255;
                    }
                }
            }
            
            // ì²˜ë¦¬ëœ ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ ë‹¤ì‹œ ìº”ë²„ìŠ¤ì— ì ìš©
            const finalImageData = new ImageData(processedData, width, height);
            tempCtx.putImageData(finalImageData, 0, 0);
            
            // ìµœì¢… ìº”ë²„ìŠ¤ì— íˆ¬ëª… ë°°ê²½ìœ¼ë¡œ ê·¸ë¦¬ê¸°
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, x, y, imgWidth, imgHeight);
        }

        // Render ë°°í¬ URL
        const REMOVE_BG_API_URL = 'https://image-bg-backend.onrender.com/api/remove_bg';
        const REMOVE_BG_HEALTH_URL = 'https://image-bg-backend.onrender.com/api/health';
        
        // ë°±ì—”ë“œ ìƒíƒœ í™•ì¸
        async function checkBackendHealth() {
            try {
                const response = await fetch(REMOVE_BG_HEALTH_URL, {
                    method: 'GET',
                    signal: AbortSignal.timeout(5000), // 5ì´ˆ íƒ€ì„ì•„ì›ƒ
                });
                return response.ok;
            } catch (error) {
                return false;
            }
        }
        
        // ë°±ì—”ë“œ ìƒíƒœ ì¸ë””ì¼€ì´í„° ì—…ë°ì´íŠ¸
        function updateBackendStatus(isOnline) {
            const indicator = document.getElementById('backendStatusIndicator');
            const statusText = document.getElementById('backendStatusText');
            
            if (isOnline) {
                indicator.className = 'status-indicator online';
                statusText.textContent = 'ë°±ì—”ë“œ ì—°ê²°ë¨';
            } else {
                indicator.className = 'status-indicator offline';
                statusText.textContent = 'ë°±ì—”ë“œ ì˜¤í”„ë¼ì¸';
            }
        }
        
        // ë°±ì—”ë“œ ìƒíƒœ ì£¼ê¸°ì  í™•ì¸
        async function checkBackendStatus() {
            const indicator = document.getElementById('backendStatusIndicator');
            const statusText = document.getElementById('backendStatusText');
            
            indicator.className = 'status-indicator checking';
            statusText.textContent = 'ë°±ì—”ë“œ í™•ì¸ ì¤‘...';
            
            const isOnline = await checkBackendHealth();
            updateBackendStatus(isOnline);
        }
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë° ì£¼ê¸°ì ìœ¼ë¡œ ìƒíƒœ í™•ì¸
        window.addEventListener('load', () => {
            checkBackendStatus();
            // 30ì´ˆë§ˆë‹¤ ìƒíƒœ í™•ì¸
            setInterval(checkBackendStatus, 30000);
        });

        async function removeBackgroundViaApi(file, width, height) {
            if (!REMOVE_BG_API_URL) {
                throw new Error('REMOVE_BG_API_URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('width', String(width));
            formData.append('height', String(height));

            try {
                // íƒ€ì„ì•„ì›ƒ ì„¤ì • (Render ë¬´ë£Œ í”Œëœ ì½œë“œ ìŠ¤íƒ€íŠ¸ ëŒ€ì‘: 60ì´ˆ)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);
                
                const response = await fetch(REMOVE_BG_API_URL, {
                    method: 'POST',
                    body: formData,
                    signal: controller.signal,
                });
                
                clearTimeout(timeoutId);

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`ë°±ì—”ë“œ ì˜¤ë¥˜ (${response.status}): ${text}`);
                }

                return await response.blob(); // PNG with alpha
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw new Error('ë°±ì—”ë“œ íƒ€ì„ì•„ì›ƒ (60ì´ˆ ì´ˆê³¼). Render ë¬´ë£Œ í”Œëœì€ ì²« ìš”ì²­ ì‹œ 15ì´ˆ ì •ë„ ì§€ì—°ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    throw new Error('ë°±ì—”ë“œ ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. Render.com ì„œë¹„ìŠ¤ê°€ ë‹¤ìš´ë˜ì—ˆê±°ë‚˜ ë„¤íŠ¸ì›Œí¬ ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                }
                throw error;
            }
        }

        // í™”ì´íŠ¸ ë°°ê²½ ìƒí’ˆìš© í¬ë¡­ (í…ìŠ¤íŠ¸/ì—¬ë°± ì œê±°, JPG ì „ìš© ëª¨ë“œ) - í´ë°±ìš©
        function cropWhiteBackground(canvas, ctx) {
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            let top = height, bottom = -1, left = width, right = -1;
            const topIgnore = Math.floor(height * 0.22); // ìƒë‹¨ í…ìŠ¤íŠ¸ ì˜ì—­ ë¬´ì‹œ

            // í°ìƒ‰ íŒë‹¨: RGB ëª¨ë‘ ë†’ê³ , ë°ê¸°ë„ ë†’ì•„ì•¼ í•¨
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // í°ìƒ‰ íŒë‹¨: ë°ê¸° + RGB ëª¨ë‘ ë†’ì•„ì•¼ í•¨ (ë” ì •í™•í•œ ê°ì§€)
                    const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                    const isVeryBright = brightness > 245; // ë°ê¸° ì„ê³„ê°’ ìƒí–¥
                    const isWhiteRGB = r > 240 && g > 240 && b > 240; // RGB ëª¨ë‘ ë†’ì•„ì•¼ í•¨
                    const isWhite = isVeryBright && isWhiteRGB;
                    
                    // ìƒë‹¨ ì˜ì—­ì€ í…ìŠ¤íŠ¸ê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë” ì—„ê²©í•˜ê²Œ
                    if (y < topIgnore) {
                        // ìƒë‹¨ ì˜ì—­: ë” ì—„ê²©í•œ í°ìƒ‰ íŒë‹¨
                        const topIsWhite = brightness > 250 && r > 245 && g > 245 && b > 245;
                        if (!topIsWhite) {
                            if (y < top) top = y;
                            if (y > bottom) bottom = y;
                            if (x < left) left = x;
                            if (x > right) right = x;
                        }
                    } else {
                        // í•˜ë‹¨ ì˜ì—­: ì¼ë°˜ í°ìƒ‰ íŒë‹¨
                        if (!isWhite) {
                            if (y < top) top = y;
                            if (y > bottom) bottom = y;
                            if (x < left) left = x;
                            if (x > right) right = x;
                        }
                    }
                }
            }

            // ìœ íš¨í•œ ë°”ìš´ë”© ë°•ìŠ¤ê°€ ì—†ìœ¼ë©´ ì›ë³¸ ê·¸ëŒ€ë¡œ ìœ ì§€
            if (bottom <= top || right <= left || top >= height || left >= width) {
                return;
            }

            // íŒ¨ë”© ì¶”ê°€ (ì˜ë¦¼ ë°©ì§€)
            const padding = Math.max(20, Math.min(width, height) * 0.03); // ìµœì†Œ 20px ë˜ëŠ” 3%
            const cropW = right - left + 1 + padding * 2;
            const cropH = bottom - top + 1 + padding * 2;
            
            // íŒ¨ë”©ì„ ê³ ë ¤í•œ í¬ë¡­ ì¢Œí‘œ (ê²½ê³„ ì²´í¬)
            let cropLeft = Math.max(0, left - padding);
            let cropTop = Math.max(0, top - padding);
            let cropRight = Math.min(width - 1, right + padding);
            let cropBottom = Math.min(height - 1, bottom + padding);
            
            const finalCropW = cropRight - cropLeft + 1;
            const finalCropH = cropBottom - cropTop + 1;

            const tmp = document.createElement('canvas');
            tmp.width = finalCropW;
            tmp.height = finalCropH;
            const tctx = tmp.getContext('2d');
            tctx.imageSmoothingEnabled = true;
            tctx.imageSmoothingQuality = 'high';
            tctx.drawImage(canvas, cropLeft, cropTop, finalCropW, finalCropH, 0, 0, finalCropW, finalCropH);

            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, width, height);
            // ë°ìŠ¤í¬í†± ë²„ì „ê³¼ ë™ì¼: thumbnail ë°©ì‹ (width, height ë‘˜ ë‹¤ ì²´í¬)
            let newW = finalCropW;
            let newH = finalCropH;
            // ë‘˜ ë‹¤ size ì•ˆì— ë“¤ì–´ê°€ë„ë¡ ìŠ¤ì¼€ì¼ ì¡°ì • (í° ìª½ë§Œ ì¶•ì†Œ, ì‘ì€ ê±´ ê·¸ëŒ€ë¡œ)
            if (newW > width || newH > height) {
                const scale = Math.min(width / newW, height / newH);
                newW = finalCropW * scale;
                newH = finalCropH * scale;
            }
            // ì‘ì€ ê±´ ê·¸ëŒ€ë¡œ ìœ ì§€ (ì—…ìŠ¤ì¼€ì¼ ì•ˆ í•¨)
            const dx = (width - newW) / 2;
            const dy = (height - newH) / 2;
            ctx.drawImage(tmp, dx, dy, newW, newH);
        }

        async function processImage(file, width, height, removeBg, format) {
            return new Promise(async (resolve, reject) => {
                try {
                    const isJpg = (format === 'jpg' || format === 'jpeg');
                    
                    // ë°°ê²½ì œê±° ëª¨ë“œ
                    if (removeBg) {
                        // 1ìˆœìœ„: ë°±ì—”ë“œ AI ë°°ê²½ì œê±° (JPG/PNG/WEBP ëª¨ë‘ ê³µí†µ)
                        const backendAvailable = await checkBackendHealth();
                        if (backendAvailable) {
                            try {
                                const sourceBlob = await removeBackgroundViaApi(file, width, height);
                                const sourceFile = new File(
                                    [sourceBlob],
                                    file.name.replace(/\.[^/.]+$/, '') + '_nobg.png',
                                    { type: 'image/png' }
                                );
                                
                                const img = new Image();
                                img.onload = () => {
                                    try {
                                        const canvas = document.createElement('canvas');
                                        canvas.width = width;
                                        canvas.height = height;
                                        const ctx = canvas.getContext('2d');
                                        
                                        // ê³ í’ˆì§ˆ ë³´ê°„ ì„¤ì •
                                        ctx.imageSmoothingEnabled = true;
                                        ctx.imageSmoothingQuality = 'high';
                                        
                                        // ë°ìŠ¤í¬í†± ë²„ì „ê³¼ ë™ì¼: thumbnail ë°©ì‹
                                        let newWidth = img.width;
                                        let newHeight = img.height;
                                        if (newWidth > width || newHeight > height) {
                                            const scale = Math.min(width / newWidth, height / newHeight);
                                            newWidth = img.width * scale;
                                            newHeight = img.height * scale;
                                        }
                                        const x = (width - newWidth) / 2;
                                        const y = (height - newHeight) / 2;
                                        
                                        // JPGëŠ” í° ë°°ê²½ìœ¼ë¡œ í”Œë˜íŠ¼, PNG/WEBPëŠ” íˆ¬ëª… ë°°ê²½ ìœ ì§€
                                        if (isJpg) {
                                            ctx.fillStyle = '#FFFFFF';
                                            ctx.fillRect(0, 0, width, height);
                                            ctx.drawImage(img, x, y, newWidth, newHeight);
                                        } else {
                                            ctx.clearRect(0, 0, width, height);
                                            ctx.drawImage(img, x, y, newWidth, newHeight);
                                        }
                                        
                                        // ì¶œë ¥ í¬ë§· ì„¤ì •
                                        let outputFormat = format;
                                        let mimeType = (isJpg ? 'image/jpeg' : `image/${format}`);
                                        
                                        // í’ˆì§ˆ ì„¤ì •
                                        const quality = isJpg
                                            ? 1.0
                                            : (outputFormat === 'webp' ? 0.95 : undefined);
                                        
                                        canvas.toBlob((blob) => {
                                            if (!blob) {
                                                reject(new Error('ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨'));
                                                return;
                                            }
                                            
                                            const processedFile = new File(
                                                [blob],
                                                file.name.replace(/\.[^/.]+$/, '') + '_edited.' + outputFormat,
                                                { type: mimeType }
                                            );
                                            
                                            resolve({
                                                original: file.name,
                                                processed: processedFile,
                                                url: URL.createObjectURL(blob)
                                            });
                                        }, mimeType, quality);
                                    } catch (error) {
                                        reject(error);
                                    }
                                };
                                img.onerror = () => reject(new Error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨'));
                                img.src = URL.createObjectURL(sourceFile);
                                return;
                            } catch (err) {
                                console.warn('ë°±ì—”ë“œ ë°°ê²½ì œê±° ì‹¤íŒ¨:', err.message);
                                // ë°±ì—”ë“œ ì‹¤íŒ¨ ì‹œ ë¡œì»¬ í´ë°±ìœ¼ë¡œ ì§„í–‰
                            }
                        } else {
                            console.warn('ë°±ì—”ë“œ ì„œë²„ê°€ ì‘ë‹µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¡œì»¬ í´ë°± ëª¨ë“œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.');
                        }
                        
                        // 2ìˆœìœ„: ë¡œì»¬ í´ë°± ì²˜ë¦¬ (í™”ì´íŠ¸ ë°°ê²½ í¬ë¡­ ë“±)
                        return processImageLocal(file, width, height, removeBg, format, resolve, reject);
                    } else {
                        // ì¼ë°˜ ëª¨ë“œ: ë¡œì»¬ ë¦¬ì‚¬ì´ì§•
                        processImageLocal(file, width, height, removeBg, format, resolve, reject);
                    }
                } catch (outer) {
                    reject(outer);
                }
            });
        }
        
        function processImageLocal(file, width, height, removeBg, format, resolve, reject) {
            const img = new Image();
            img.onload = () => {
                try {
                    const isJpgLocal = (format === 'jpg' || format === 'jpeg');
                    
                    if (removeBg && isJpgLocal) {
                        // JPG + ë°°ê²½ì œê±°: ì›ë³¸ í¬ê¸°ì—ì„œ í° ë°°ê²½ í¬ë¡­ (ë°ìŠ¤í¬í†± ë²„ì „ê³¼ ë™ì¼)
                        const originalCanvas = document.createElement('canvas');
                        originalCanvas.width = img.width;
                        originalCanvas.height = img.height;
                        const originalCtx = originalCanvas.getContext('2d');
                        
                        originalCtx.imageSmoothingEnabled = true;
                        originalCtx.imageSmoothingQuality = 'high';
                        originalCtx.drawImage(img, 0, 0, img.width, img.height);
                        
                        // í° ë°°ê²½ í¬ë¡­
                        cropWhiteBackground(originalCanvas, originalCtx);
                        
                        // ìµœì¢… ì¶œë ¥ìš© ìº”ë²„ìŠ¤ (600x600)
                        const finalCanvas = document.createElement('canvas');
                        finalCanvas.width = width;
                        finalCanvas.height = height;
                        const finalCtx = finalCanvas.getContext('2d');
                        
                        finalCtx.imageSmoothingEnabled = true;
                        finalCtx.imageSmoothingQuality = 'high';
                        finalCtx.fillStyle = '#FFFFFF';
                        finalCtx.fillRect(0, 0, width, height);
                        
                        // í¬ë¡­ëœ ì´ë¯¸ì§€ë¥¼ 600x600ì— ë§ì¶° ë¦¬ì‚¬ì´ì§•
                        let newW = originalCanvas.width;
                        let newH = originalCanvas.height;
                        if (newW > width || newH > height) {
                            const scale = Math.min(width / newW, height / newH);
                            newW = originalCanvas.width * scale;
                            newH = originalCanvas.height * scale;
                        }
                        const dx = (width - newW) / 2;
                        const dy = (height - newH) / 2;
                        finalCtx.drawImage(originalCanvas, dx, dy, newW, newH);
                        
                        const outputFormat = format;
                        const mimeType = 'image/jpeg';
                        const quality = 1.0;
                        
                        finalCanvas.toBlob((blob) => {
                            if (!blob) {
                                reject(new Error('ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨'));
                                return;
                            }
                            
                            const processedFile = new File(
                                [blob],
                                file.name.replace(/\.[^/.]+$/, '') + '_edited.' + outputFormat,
                                { type: mimeType }
                            );
                            
                            resolve({
                                original: file.name,
                                processed: processedFile,
                                url: URL.createObjectURL(blob)
                            });
                        }, mimeType, quality);
                        return;
                    }
                    
                    // ì¼ë°˜ ëª¨ë“œ ë˜ëŠ” PNG/WEBP ë°°ê²½ì œê±°
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    
                    // ê³ í’ˆì§ˆ ë³´ê°„ ì„¤ì •
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // ë°ìŠ¤í¬í†± ë²„ì „ê³¼ ë™ì¼: thumbnail ë°©ì‹
                    let newWidth = img.width;
                    let newHeight = img.height;
                    if (newWidth > width || newHeight > height) {
                        const scale = Math.min(width / newWidth, height / newHeight);
                        newWidth = img.width * scale;
                        newHeight = img.height * scale;
                    }
                    const x = (width - newWidth) / 2;
                    const y = (height - newHeight) / 2;
                    
                    if (removeBg) {
                        // PNG/WEBP + ë°°ê²½ì œê±°: íˆ¬ëª… ë°°ê²½ (ë¡œì»¬ì—ì„œëŠ” ë‹¨ìˆœ ë¦¬ì‚¬ì´ì§•ë§Œ)
                        ctx.clearRect(0, 0, width, height);
                        ctx.drawImage(img, x, y, newWidth, newHeight);
                    } else {
                        // ì¼ë°˜ ëª¨ë“œ: í°ìƒ‰ ë°°ê²½
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, width, height);
                        ctx.drawImage(img, x, y, newWidth, newHeight);
                    }
                    
                    // ì¶œë ¥ í¬ë§· ì„¤ì • (ì‚¬ìš©ìê°€ ì„ íƒí•œ í¬ë§· ê·¸ëŒ€ë¡œ ì‚¬ìš©)
                    let outputFormat = format;
                    let mimeType = (format === 'jpg' || format === 'jpeg') ? 'image/jpeg' : `image/${format}`;
                    
                    // JPG + ë°°ê²½ì œê±°ëŠ” í° ë°°ê²½ìœ¼ë¡œ í”Œë˜íŠ¼í–ˆìœ¼ë¯€ë¡œ JPGë¡œ ì €ì¥ ê°€ëŠ¥
                    // JPGëŠ” ìµœëŒ€ í’ˆì§ˆ(1.0)ë¡œ ìƒ‰ìƒ ë³´ì¡´
                    const quality = (outputFormat === 'jpg' || outputFormat === 'jpeg') ? 1.0 :
                                   (outputFormat === 'webp') ? 0.95 : undefined;
                    
                    canvas.toBlob((blob) => {
                        if (!blob) {
                            reject(new Error('ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨'));
                            return;
                        }
                        
                        const processedFile = new File(
                            [blob],
                            file.name.replace(/\.[^/.]+$/, '') + '_edited.' + outputFormat,
                            { type: mimeType }
                        );
                        
                        resolve({
                            original: file.name,
                            processed: processedFile,
                            url: URL.createObjectURL(blob)
                        });
                    }, mimeType, quality);
                } catch (error) {
                    reject(error);
                }
            };
            img.onerror = () => reject(new Error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨'));
            img.src = URL.createObjectURL(file);
        }

        function downloadAllImages() {
            if (processedImages.length === 0) {
                showImageMessage('ë‹¤ìš´ë¡œë“œí•  ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.', 'error');
                return;
            }
            
            processedImages.forEach((item, index) => {
                setTimeout(() => {
                    const a = document.createElement('a');
                    a.href = item.url;
                    a.download = item.processed.name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }, index * 200);
            });
            
            showImageMessage(`${processedImages.length}ê°œ íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹œì‘`, 'info');
        }

        function clearImageAll() {
            imageFiles = [];
            processedImages = [];
            document.getElementById('imagePreviewContainer').innerHTML = '';
            document.getElementById('imagePreviewSection').style.display = 'none';
            document.getElementById('imageFileInput').value = '';
            document.getElementById('imageProcessBtn').disabled = true;
            document.getElementById('imageClearBtn').style.display = 'none';
            updateImageProgress(0);
            updateImageFileCount();
            
            const downloadBtn = document.getElementById('imageDownloadAllBtn');
            if (downloadBtn) downloadBtn.remove();
        }

        function updateImageProgress(percent) {
            const container = document.getElementById('imageProgressContainer');
            const bar = document.getElementById('imageProgressBar');
            if (percent > 0) {
                container.style.display = 'block';
                bar.style.width = percent + '%';
                bar.textContent = Math.round(percent) + '%';
            } else {
                container.style.display = 'none';
            }
        }

        function updateImagePreviewStatus(index, status, className) {
            const item = document.getElementById(`imagePreview-${index}`);
            if (item) {
                const statusEl = item.querySelector('.status');
                statusEl.textContent = status;
                statusEl.className = 'status ' + className;
            }
        }

        function showImageMessage(message, type = 'success') {
            const area = document.getElementById('imageMessageArea');
            const messageClass = type === 'error' ? 'error-message' : 
                                 type === 'info' ? 'info-message' : 'success-message';
            area.innerHTML = `<div class="message ${messageClass}">${message}</div>`;
            setTimeout(() => { area.innerHTML = ''; }, 5000);
        }

        // ========== WEBP ë³€í™˜ ì²˜ë¦¬ ==========
        let webpFiles = [];
        let processedWebp = [];
        let currentWatermarkPosition = 'mid-center';

        // ì˜ìƒ íŒŒì¼ ì„ íƒ
        document.getElementById('webpFileInput').addEventListener('change', (e) => {
            handleWebpFiles(e.target.files);
        });

        // ì˜ìƒ ë“œë˜ê·¸ ì•¤ ë“œë¡­
        const webpUploadSection = document.getElementById('webpUploadSection');
        webpUploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            webpUploadSection.classList.add('dragover');
        });
        webpUploadSection.addEventListener('dragleave', () => {
            webpUploadSection.classList.remove('dragover');
        });
        webpUploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            webpUploadSection.classList.remove('dragover');
            handleWebpFiles(e.dataTransfer.files);
        });

        function handleWebpFiles(files) {
            webpFiles = Array.from(files).filter(f => f.type.startsWith('video/'));
            updateWebpFileCount();
            updateWebpPreview();
            document.getElementById('webpProcessBtn').disabled = webpFiles.length === 0;
            document.getElementById('webpClearBtn').style.display = webpFiles.length > 0 ? 'inline-block' : 'none';
        }

        function updateWebpFileCount() {
            const countEl = document.getElementById('webpFileCount');
            if (webpFiles.length > 0) {
                countEl.textContent = `ì„ íƒëœ íŒŒì¼: ${webpFiles.length}ê°œ`;
                countEl.style.display = 'block';
            } else {
                countEl.style.display = 'none';
            }
        }

        function updateWebpPreview() {
            const container = document.getElementById('webpPreviewContainer');
            container.innerHTML = '';
            
            webpFiles.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const div = document.createElement('div');
                    div.className = 'preview-item';
                    div.id = `webpPreview-${index}`;
                    div.innerHTML = `
                        <video src="${e.target.result}" controls style="max-height: 200px;"></video>
                        <div class="filename">${file.name}</div>
                        <div class="status">ëŒ€ê¸° ì¤‘</div>
                    `;
                    container.appendChild(div);
                };
                reader.readAsDataURL(file);
            });
            
            document.getElementById('webpPreviewSection').style.display = webpFiles.length > 0 ? 'block' : 'none';
        }

        // ì›Œí„°ë§ˆí¬ ì„¤ì • ì—…ë°ì´íŠ¸
        document.getElementById('watermarkText').addEventListener('input', updateWatermarkPreview);
        document.getElementById('watermarkColor').addEventListener('input', updateWatermarkPreview);
        document.getElementById('fontSizeSlider').addEventListener('input', (e) => {
            document.getElementById('fontSizeValue').textContent = e.target.value;
            updateWatermarkPreview();
        });
        document.getElementById('opacitySlider').addEventListener('input', (e) => {
            document.getElementById('opacityValue').textContent = e.target.value + '%';
            updateWatermarkPreview();
        });

        function updateWatermarkPreview() {
            const text = document.getElementById('watermarkText').value;
            const color = document.getElementById('watermarkColor').value;
            const size = document.getElementById('fontSizeSlider').value;
            const opacity = document.getElementById('opacitySlider').value / 100;
            
            const preview = document.getElementById('watermarkPreview');
            const previewText = document.getElementById('watermarkPreviewText');
            previewText.textContent = text;
            previewText.style.color = color;
            previewText.style.fontSize = size + 'px';
            previewText.style.opacity = opacity;
        }

        function selectPosition(pos) {
            currentWatermarkPosition = pos;
            document.querySelectorAll('.position-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.pos === pos) {
                    btn.classList.add('active');
                }
            });
        }

        // ì˜ìƒ ê¸¸ì´ ì„ íƒ
        document.querySelectorAll('input[name="videoLength"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                document.getElementById('timeRangeRow').style.display = 
                    e.target.value === 'partial' ? 'flex' : 'none';
            });
        });

        // ffmpeg.wasm ì´ˆê¸°í™”
        let ffmpeg = null;
        let ffmpegLoaded = false;
        let ffmpegLoading = false;

        async function loadFFmpeg() {
            if (ffmpegLoaded) return ffmpeg;
            if (ffmpegLoading) {
                // ì´ë¯¸ ë¡œë”© ì¤‘ì´ë©´ ëŒ€ê¸°
                while (ffmpegLoading && !ffmpegLoaded) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                return ffmpeg;
            }
            
            ffmpegLoading = true;
            
            try {
                // FFmpeg ì „ì—­ ë³€ìˆ˜ í™•ì¸
                if (typeof FFmpeg === 'undefined') {
                    throw new Error('FFmpeg ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
                }
                
                showWebpMessage('FFmpeg ë¡œë”© ì¤‘... (ì²˜ìŒ í•œ ë²ˆë§Œ, ì•½ 30ì´ˆ ì†Œìš”)', 'info');
                
                // FFmpeg ëª¨ë“ˆ í™•ì¸
                if (!FFmpeg.createFFmpeg || !FFmpeg.fetchFile) {
                    throw new Error('FFmpeg ëª¨ë“ˆì´ ì˜¬ë°”ë¥´ê²Œ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                }
                
                const { createFFmpeg, fetchFile } = FFmpeg;
                ffmpeg = createFFmpeg({ 
                    log: false,
                    corePath: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js'
                });
                
                await ffmpeg.load();
                ffmpegLoaded = true;
                ffmpegLoading = false;
                showWebpMessage('âœ… FFmpeg ë¡œë”© ì™„ë£Œ! ì´ì œ ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 'success');
                return ffmpeg;
            } catch (error) {
                ffmpegLoading = false;
                showWebpMessage('âŒ FFmpeg ë¡œë”© ì‹¤íŒ¨: ' + error.message, 'error');
                throw error;
            }
        }

        // ì‹œê°„ ë¬¸ìì—´ì„ ì´ˆë¡œ ë³€í™˜ (HH:MM:SS -> seconds)
        function timeToSeconds(timeStr) {
            const parts = timeStr.split(':');
            return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
        }

        // ì´ˆë¥¼ ì‹œê°„ ë¬¸ìì—´ë¡œ ë³€í™˜
        function secondsToTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }

        async function processWebp() {
            if (webpFiles.length === 0) {
                showWebpMessage('MP4 íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', 'error');
                return;
            }

            const settings = {
                watermarkText: document.getElementById('watermarkText').value,
                watermarkColor: document.getElementById('watermarkColor').value,
                fontSize: parseInt(document.getElementById('fontSizeSlider').value),
                opacity: parseFloat(document.getElementById('opacitySlider').value) / 100,
                position: currentWatermarkPosition,
                videoLength: document.querySelector('input[name="videoLength"]:checked').value,
                startTime: document.getElementById('startTime').value,
                endTime: document.getElementById('endTime').value,
                width: parseInt(document.getElementById('videoWidth').value),
                format: document.querySelector('input[name="webpFormat"]:checked').value
            };

            document.getElementById('webpProcessBtn').disabled = true;
            processedWebp = [];
            updateWebpProgress(0);

            try {
                // FFmpeg ë¡œë“œ
                await loadFFmpeg();
                
                for (let i = 0; i < webpFiles.length; i++) {
                    const file = webpFiles[i];
                    const fileProgress = ((i) / webpFiles.length) * 100;
                    updateWebpProgress(fileProgress);
                    updateWebpPreviewStatus(i, 'ì²˜ë¦¬ ì¤‘...', 'processing');
                    
                    try {
                        showWebpMessage(`${file.name} ë³€í™˜ ì¤‘...`, 'info');
                        
                        // FFmpeg í™•ì¸
                        if (!ffmpeg || typeof FFmpeg === 'undefined' || !FFmpeg.fetchFile) {
                            throw new Error('FFmpegê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
                        }
                        
                        // íŒŒì¼ì„ ë©”ëª¨ë¦¬ì— ì“°ê¸°
                        const { fetchFile } = FFmpeg;
                        const inputData = await fetchFile(file);
                        ffmpeg.FS('writeFile', 'input.mp4', inputData);
                        
                        // FFmpeg ëª…ë ¹ì–´ êµ¬ì„±
                        const outputFile = `output.${settings.format}`;
                        const args = ['-i', 'input.mp4'];
                        
                        // ì‹œê°„ êµ¬ê°„ ì„¤ì •
                        if (settings.videoLength === 'partial') {
                            const startSeconds = timeToSeconds(settings.startTime);
                            const endSeconds = timeToSeconds(settings.endTime);
                            const duration = endSeconds - startSeconds;
                            args.push('-ss', settings.startTime);
                            args.push('-t', secondsToTime(duration));
                        }
                        
                        // ë¹„ë””ì˜¤ í•„í„° êµ¬ì„±
                        let vf = `scale=${settings.width}:-1`;
                        
                        // ì›Œí„°ë§ˆí¬ ì¶”ê°€ (ê°„ë‹¨í•œ í…ìŠ¤íŠ¸ ì˜¤ë²„ë ˆì´)
                        if (settings.watermarkText) {
                            const colorHex = settings.watermarkColor.replace('#', '');
                            const r = parseInt(colorHex.substr(0, 2), 16);
                            const g = parseInt(colorHex.substr(2, 2), 16);
                            const b = parseInt(colorHex.substr(4, 2), 16);
                            
                            // ìœ„ì¹˜ ê³„ì‚°
                            let x = '10', y = '10';
                            if (settings.position.includes('center')) {
                                x = '(w-text_w)/2';
                            } else if (settings.position.includes('right')) {
                                x = 'w-text_w-10';
                            }
                            if (settings.position.includes('mid')) {
                                y = '(h-text_h)/2';
                            } else if (settings.position.includes('bot')) {
                                y = 'h-text_h-10';
                            }
                            
                            const escapedText = settings.watermarkText.replace(/'/g, "\\'");
                            vf += `,drawtext=text='${escapedText}':fontsize=${settings.fontSize}:fontcolor=${r}:${g}:${b}@${Math.floor(settings.opacity * 255)}:x=${x}:y=${y}`;
                        }
                        
                        args.push('-vf', vf);
                        
                        // ì¶œë ¥ í˜•ì‹ì— ë”°ë¥¸ ì¸ì½”ë” ì„¤ì •
                        if (settings.format === 'webp') {
                            args.push('-c:v', 'libwebp', '-loop', '0', '-quality', '80', '-an', outputFile);
                        } else if (settings.format === 'gif') {
                            // GIFëŠ” 2ë‹¨ê³„ë¡œ ì²˜ë¦¬ (íŒ”ë ˆíŠ¸ ìƒì„± í›„ ë³€í™˜)
                            const paletteFile = 'palette.png';
                            // 1ë‹¨ê³„: íŒ”ë ˆíŠ¸ ìƒì„±
                            const paletteArgs = ['-i', 'input.mp4'];
                            if (settings.videoLength === 'partial') {
                                const startSeconds = timeToSeconds(settings.startTime);
                                const endSeconds = timeToSeconds(settings.endTime);
                                const duration = endSeconds - startSeconds;
                                paletteArgs.push('-ss', settings.startTime);
                                paletteArgs.push('-t', secondsToTime(duration));
                            }
                            paletteArgs.push('-vf', `fps=12,scale=${settings.width}:-1:flags=lanczos,palettegen`, paletteFile);
                            await ffmpeg.run(...paletteArgs);
                            
                            // 2ë‹¨ê³„: GIF ìƒì„±
                            args = ['-i', 'input.mp4', '-i', paletteFile];
                            if (settings.videoLength === 'partial') {
                                const startSeconds = timeToSeconds(settings.startTime);
                                const endSeconds = timeToSeconds(settings.endTime);
                                const duration = endSeconds - startSeconds;
                                args.push('-ss', settings.startTime);
                                args.push('-t', secondsToTime(duration));
                            }
                            args.push('-filter_complex', `[0:v]fps=12,scale=${settings.width}:-1:flags=lanczos[scaled];[scaled][1:v]paletteuse`, outputFile);
                        }
                        
                        if (settings.format !== 'gif') {
                            args.push(outputFile);
                        }
                        
                        // ë³€í™˜ ì‹¤í–‰
                        await ffmpeg.run(...args);
                        
                        // ê²°ê³¼ íŒŒì¼ ì½ê¸°
                        const data = ffmpeg.FS('readFile', outputFile);
                        const blob = new Blob([data.buffer], { 
                            type: settings.format === 'webp' ? 'image/webp' : 'image/gif' 
                        });
                        const url = URL.createObjectURL(blob);
                        
                        // íŒŒì¼ ì‹œìŠ¤í…œ ì •ë¦¬
                        try {
                            ffmpeg.FS('unlink', 'input.mp4');
                            ffmpeg.FS('unlink', outputFile);
                            if (settings.format === 'gif') {
                                ffmpeg.FS('unlink', 'palette.png');
                            }
                        } catch (e) {}
                        
                        updateWebpPreviewStatus(i, 'ì™„ë£Œ âœ“', 'complete');
                        processedWebp.push({
                            original: file.name,
                            processed: new File([blob], file.name.replace(/\.[^/.]+$/, '') + '.' + settings.format, { 
                                type: blob.type 
                            }),
                            url: url
                        });
                        
                        // ìë™ ë‹¤ìš´ë¡œë“œ
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = file.name.replace(/\.[^/.]+$/, '') + '.' + settings.format;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        
                    } catch (error) {
                        updateWebpPreviewStatus(i, 'ì˜¤ë¥˜ âœ—', 'error');
                        showWebpMessage(`${file.name} ë³€í™˜ ì‹¤íŒ¨: ${error.message}`, 'error');
                        console.error('Conversion error:', error);
                    }
                }

                updateWebpProgress(100);
                if (processedWebp.length > 0) {
                    showWebpMessage(`âœ… ${processedWebp.length}ê°œ íŒŒì¼ ë³€í™˜ ì™„ë£Œ!`, 'success');
                }
                
            } catch (error) {
                showWebpMessage('ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message, 'error');
            } finally {
                document.getElementById('webpProcessBtn').disabled = false;
            }
        }

        function clearWebpAll() {
            webpFiles = [];
            processedWebp = [];
            document.getElementById('webpPreviewContainer').innerHTML = '';
            document.getElementById('webpPreviewSection').style.display = 'none';
            document.getElementById('webpFileInput').value = '';
            document.getElementById('webpProcessBtn').disabled = true;
            document.getElementById('webpClearBtn').style.display = 'none';
            updateWebpProgress(0);
            updateWebpFileCount();
        }

        function updateWebpProgress(percent) {
            const container = document.getElementById('webpProgressContainer');
            const bar = document.getElementById('webpProgressBar');
            if (percent > 0) {
                container.style.display = 'block';
                bar.style.width = percent + '%';
                bar.textContent = Math.round(percent) + '%';
            } else {
                container.style.display = 'none';
            }
        }

        function updateWebpPreviewStatus(index, status, className) {
            const item = document.getElementById(`webpPreview-${index}`);
            if (item) {
                const statusEl = item.querySelector('.status');
                statusEl.textContent = status;
                statusEl.className = 'status ' + className;
            }
        }

        function showWebpMessage(message, type = 'success') {
            const area = document.getElementById('webpMessageArea');
            const messageClass = type === 'error' ? 'error-message' : 
                                 type === 'info' ? 'info-message' : 'success-message';
            area.innerHTML = `<div class="message ${messageClass}">${message}</div>`;
            setTimeout(() => { area.innerHTML = ''; }, 5000);
        }

        // ì´ˆê¸° ì›Œí„°ë§ˆí¬ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
        updateWatermarkPreview();
    </script>
</body>
</html>

